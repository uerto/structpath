{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"uerto-structpath","text":"<p><code>uerto-structpath</code>is a Python library for querying, traversing, and manipulating structured data using path expressions.</p> <p>A Structpath is a path expression that allows to navigate through nested data structures. It's similar to JSONPath or XPath. By design, it is less powerful, as it does not allow for complex queries. It is more powerful in a different regard, as it allows defining variables in a path.</p> <p>A typical Structpath looks like this:</p> <pre><code>$users.admin.permissions[2].level\n</code></pre> <p>Structpath uses a simple syntax:</p> <ul> <li><code>$</code> represents the root of the document</li> <li><code>.</code> separates path segments for object properties</li> <li><code>[n]</code> accesses array elements</li> <li><code>#varname</code> defines variables that can be resolved at runtime</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install structpath\n</code></pre>"},{"location":"#example","title":"Example","text":"<pre><code>from structpath import Structpath\n\ndata = {\n    \"users\": {\n        \"admin\": {\"permissions\": [\"read\", \"write\", \"execute\"]},\n        \"guest\": {\"permissions\": [\"read\"]}\n    }\n}\n\n# Parse a path and get a value\npath = Structpath.parse(\"$users.admin.permissions[0]\")\nvalue = path.get(data)\nassert value == \"read\"\n\n# Use variables in paths\npath_with_var = Structpath.parse(\"$users.#role.permissions[0]\")\nvalue = path_with_var.get(data, {\"role\": \"guest\"})\nassert value == \"read\"\n\n# Write to a nested location\npath.write(data, \"read-only\")\nassert data[\"users\"][\"admin\"][\"permissions\"][0] == \"read-only\"\n\n# Walk through data\nfor path_str, value in Structpath.walk(data):\n    # Process each path and value\n    pass\n</code></pre>"},{"location":"API/","title":"API","text":""},{"location":"API/#structpath.Structpath.parse","title":"<code>structpath.Structpath.parse(path_str)</code>  <code>staticmethod</code>","text":"<p>Parse a structpath string into a Structpath object.</p> <p>Parameters:</p> Name Type Description Default <code>path_str</code> <code>str</code> <p>A string representation of a path</p> required <p>Returns:</p> Type Description <code>Structpath</code> <p>A new Structpath object</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the path string cannot be parsed</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; path = Structpath.parse(\"$users[0].name\")\n&gt;&gt;&gt; path.get(data)  # Returns \"Alice\"\n</code></pre>"},{"location":"API/#structpath.Structpath.get","title":"<code>structpath.Structpath.get(data, vars=None)</code>","text":"<pre><code>get(data: dict[str, V], vars: dict[str, Any] | None = None) -&gt; V\n</code></pre><pre><code>get(data: list[V], vars: dict[str, Any] | None = None) -&gt; V\n</code></pre><pre><code>get(data: Any) -&gt; Any\n</code></pre> <p>Get a value from data using this path.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The data structure to navigate</p> required <code>vars</code> <code>dict[str, Any] | None</code> <p>Optional dictionary mapping variable names to values</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The value at the path</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the path doesn't exist in the data</p> <code>IndexError</code> <p>If an index doesn't exist in the data</p> <code>TypeError</code> <p>If the path is invalid for the data structure</p> <code>ValueError</code> <p>If a variable in the path is missing from vars</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; data = {\"users\": [{\"name\": \"Alice\"}, {\"name\": \"Bob\"}]}\n&gt;&gt;&gt; path = Structpath.parse(\"$users[0].name\")\n&gt;&gt;&gt; path.get(data)  # Returns \"Alice\"\n&gt;&gt;&gt; path = Structpath.parse(\"$users[#idx].name\")\n&gt;&gt;&gt; path.get(data, {\"idx\": \"1\"})  # Returns \"Bob\"\n</code></pre>"},{"location":"API/#structpath.Structpath.write","title":"<code>structpath.Structpath.write(data=None, value=None, vars=None)</code>","text":"<pre><code>write(data: dict[str, Any], value: Any | None = None, vars: dict[str, Any] | None = None) -&gt; dict[str, Any]\n</code></pre><pre><code>write(data: list[Any], value: Any | None = None, vars: dict[str, Any] | None = None) -&gt; list[Any]\n</code></pre> <p>Write a value to a path in the data structure.</p> <p>This method creates or updates a value at the specified path in the data. If parts of the path don't exist, they will be created.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any | None</code> <p>The data structure to modify (optional)</p> <code>None</code> <code>value</code> <code>Any | None</code> <p>The value to write (optional)</p> <code>None</code> <code>vars</code> <code>dict[str, Any] | None</code> <p>Optional dictionary mapping variable names to values</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The modified data structure</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the path is invalid for the data structure</p> <code>ValueError</code> <p>If a variable in the path is missing from vars</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; data = {\"users\": []}\n&gt;&gt;&gt; path = Structpath.parse(\"$users[0].name\")\n&gt;&gt;&gt; result = path.write(data, \"Alice\")\n&gt;&gt;&gt; result\n{'users': [{'name': 'Alice'}]}\n&gt;&gt;&gt; path = Structpath.parse(\"$users.#userId.name\")\n&gt;&gt;&gt; result = path.write(data, \"Charlie\", {\"userId\": \"user3\"})\n&gt;&gt;&gt; result\n{'users': [{'name': 'Alice'}], 'user3': {'name': 'Charlie'}}\n</code></pre>"},{"location":"API/#structpath.Structpath.iter","title":"<code>structpath.Structpath.iter(data)</code>","text":"<p>Iterate over all possible variable resolutions in the data.</p> <p>For a path with variables, this method returns an iterator that yields tuples of (variable_values, value) for all possible combinations of variable values that lead to valid paths in the data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The data structure to navigate</p> required <p>Returns:</p> Type Description <code>Iterator[tuple[dict[str, str], Any]]</code> <p>An iterator yielding (variable_values, value) tuples</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; data = {\"users\": {\"user1\": {\"name\": \"Alice\"}, \"user2\": {\"name\": \"Bob\"}}}\n&gt;&gt;&gt; path = Structpath.parse(\"$users.#userId.name\")\n&gt;&gt;&gt; for vars, value in path.iter(data):\n...     print(f\"{vars['userId']}: {value}\")\nuser1: Alice\nuser2: Bob\n</code></pre>"},{"location":"API/#structpath.Structpath.walk","title":"<code>structpath.Structpath.walk(data)</code>  <code>staticmethod</code>","text":"<p>Walk through all paths in a data structure.</p> <p>This method returns an iterator that yields tuples of (Structpath, value) for every path in the data structure.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>T</code> <p>The data structure to walk through</p> required <p>Returns:</p> Type Description <code>Iterator[tuple[Structpath, Any]]</code> <p>An iterator yielding (path, value) tuples</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; data = {\"a\": [1, 2, {\"b\": 3}], \"c\": {\"d\": 4}}\n&gt;&gt;&gt; for path, value in Structpath.walk(data):\n...     print(f\"{path}: {value}\")\n$: {'a': [1, 2, {'b': 3}], 'c': {'d': 4}}\n$a: [1, 2, {'b': 3}]\n$a[0]: 1\n$a[1]: 2\n$a[2]: {'b': 3}\n$a[2].b: 3\n$c: {'d': 4}\n$c.d: 4\n</code></pre>"},{"location":"variables/","title":"Structpath Variables","text":"<p>Structpath supports variables within path expressions, allowing for dynamic path resolution at runtime. This is one of the most powerful features of Structpath, enabling flexible data access patterns.</p>"},{"location":"variables/#variable-syntax","title":"Variable Syntax","text":"<p>There are two types of variables in Structpath:</p> <ol> <li> <p>Key Variables: Used to represent object keys</p> </li> <li> <p>Syntax: <code>#variable_name</code></p> </li> <li> <p>Example: <code>$users.#userId.profile</code></p> </li> <li> <p>Index Variables: Used to represent array indices</p> </li> <li> <p>Syntax: <code>[#variable_name]</code></p> </li> <li>Example: <code>$items[#index].value</code></li> </ol>"},{"location":"variables/#resolving-variables","title":"Resolving Variables","text":"<p>Variables are resolved at runtime by providing a dictionary that maps variable names to their values. The resolution context is passed as an argument to methods like <code>get()</code>, <code>write()</code>, and others.</p> <pre><code>from structpath import Structpath\n\ndata = {\n    \"users\": {\n        \"user1\": {\"name\": \"Alice\"},\n        \"user2\": {\"name\": \"Bob\"}\n    }\n}\n\npath = Structpath.parse(\"$users.#userId.name\")\n\n# Resolve using different variable values\nalice_name = path.get(data, {\"userId\": \"user1\"})\nassert alice_name == \"Alice\"\n\nbob_name = path.get(data, {\"userId\": \"user2\"})\nassert bob_name == \"Bob\"\n</code></pre>"},{"location":"variables/#variable-rules","title":"Variable Rules","text":"<ol> <li>Uniqueness: Each variable name must be unique within a path.</li> </ol> <pre><code># This will raise an error\ntry:\n   Structpath.parse(\"$users.#var.items.#var\")\n   assert False, \"Should have raised an error\"\nexcept ValueError as e:\n   assert \"Duplicate variable\" in str(e)\n</code></pre> <ol> <li>Required Resolution: If a path contains variables, a variable context    must be provided.</li> </ol> <pre><code>path = Structpath.parse(\"$users.#userId.profile\")\n\ntry:\n   path.get(data)  # No variable context provided\n   assert False\nexcept ValueError as e:\n   assert \"Path contains variables\" in str(e)\n</code></pre> <ol> <li>Type Conversion: Index variables must be convertible to integers.</li> </ol> <pre><code>data = {\"items\": [\"a\", \"b\", \"c\"]}\npath = Structpath.parse(\"$items[#index]\")\n\n# String values that represent integers are converted automatically\nvalue = path.get(data, {\"index\": \"1\"})\nassert value == \"b\"\n\n# Non-integer values will cause an error\ntry:\n   path.get(data, {\"index\": \"not-a-number\"})\n   assert False, \"Should have raised an error\"\nexcept ValueError as e:\n   assert \"Invalid variable value\" in str(e)\n</code></pre>"},{"location":"variables/#use-cases-for-variables","title":"Use Cases for Variables","text":""},{"location":"variables/#1-parameterized-data-access","title":"1. Parameterized Data Access","text":"<p>Variables allow the same path to be reused with different parameters:</p> <pre><code>from structpath import Structpath\n\n# Configuration data\nconfig = {\n    \"environments\": {\n        \"dev\": {\n            \"database\": {\n                \"host\": \"dev-db.example.com\",\n                \"port\": 5432\n            }\n        },\n        \"prod\": {\n            \"database\": {\n                \"host\": \"prod-db.example.com\",\n                \"port\": 3306\n            }\n        }\n    }\n}\n\n# Create a parameterized path\npath = Structpath.parse(\"$environments.#env.database.host\")\n\n# Get database host for different environments\ndev_host = path.get(config, {\"env\": \"dev\"})\nassert dev_host == \"dev-db.example.com\"\n\nprod_host = path.get(config, {\"env\": \"prod\"})\nassert prod_host == \"prod-db.example.com\"\n</code></pre>"},{"location":"variables/#2-finding-all-matches-with-iter","title":"2. Finding All Matches with <code>iter()</code>","text":"<p>The <code>iter()</code> method allows you to find all possible variable resolutions for a path. It returns an iterator of (variable_dict, value) tuples:</p> <pre><code>from structpath import Structpath\n\n# Team membership data\ndata = {\n    \"teams\": {\n        \"engineering\": {\n            \"members\": {\n                \"alice\": {\"role\": \"developer\"},\n                \"bob\": {\"role\": \"designer\"}\n            }\n        },\n        \"marketing\": {\n            \"members\": {\n                \"charlie\": {\"role\": \"manager\"},\n                \"dave\": {\"role\": \"copywriter\"}\n            }\n        }\n    }\n}\n\n# Path with multiple variables\npath = Structpath.parse(\"$teams.#teamName.members.#memberName.role\")\n\n# Find all team members and their roles\nteam_roles = {}\nfor vars_dict, role in path.iter(data):\n    team = vars_dict[\"teamName\"]\n    member = vars_dict[\"memberName\"]\n    team_roles[(team, member)] = role\n\n# Check the results\nassert team_roles[(\"engineering\", \"alice\")] == \"developer\"\nassert team_roles[(\"engineering\", \"bob\")] == \"designer\"\nassert team_roles[(\"marketing\", \"charlie\")] == \"manager\"\nassert team_roles[(\"marketing\", \"dave\")] == \"copywriter\"\n</code></pre>"},{"location":"variables/#3-dynamic-data-transformation","title":"3. Dynamic Data Transformation","text":"<p>Variables can be used to transform data based on patterns:</p> <pre><code>from structpath import Structpath\n\n# Source data\nsource = {\n    \"users\": [\n        {\"id\": \"user1\", \"name\": \"Alice\", \"email\": \"alice@example.com\"},\n        {\"id\": \"user2\", \"name\": \"Bob\", \"email\": \"bob@example.com\"}\n    ]\n}\n\n# Target data structure\ntarget = {}\n\n# Create a path with an index variable\npath = Structpath.parse(\"$users[#idx]\")\nwrite_path = Structpath.parse(\"$userMap.#id\")\n\n# Transform the data structure\nfor vars_dict, user in path.iter(source):\n    user_id = user[\"id\"]\n    write_path.write(target, user, {\"id\": user_id})\n\n# Check the result\nassert target[\"userMap\"][\"user1\"][\"name\"] == \"Alice\"\nassert target[\"userMap\"][\"user2\"][\"email\"] == \"bob@example.com\"\n</code></pre>"},{"location":"variables/#4-complex-queries","title":"4. Complex Queries","text":"<p>Variables enable complex query patterns:</p> <pre><code>from structpath import Structpath\n\n# Product inventory data\ninventory = {\n    \"categories\": {\n        \"electronics\": {\n            \"products\": [\n                {\"id\": \"e1\", \"name\": \"Phone\", \"price\": 499, \"stock\": 10},\n                {\"id\": \"e2\", \"name\": \"Laptop\", \"price\": 999, \"stock\": 5}\n            ]\n        },\n        \"books\": {\n            \"products\": [\n                {\"id\": \"b1\", \"name\": \"Python Guide\", \"price\": 29, \"stock\": 100},\n                {\"id\": \"b2\", \"name\": \"Data Science\", \"price\": 39, \"stock\": 50}\n            ]\n        }\n    }\n}\n\n# Find all products with low stock (less than 10)\nlow_stock = []\npath = Structpath.parse(\"$categories.#category.products[#idx]\")\n\nfor vars_dict, product in path.iter(inventory):\n    if product[\"stock\"] &lt; 10:\n        low_stock.append({\n            \"category\": vars_dict[\"category\"],\n            \"product\": product[\"name\"],\n            \"stock\": product[\"stock\"]\n        })\n\nassert low_stock[0][\"category\"] == \"electronics\"\nassert low_stock[0][\"product\"] == \"Laptop\"\nassert low_stock[0][\"stock\"] == 5\n</code></pre>"},{"location":"variables/#advanced-variable-usage","title":"Advanced Variable Usage","text":""},{"location":"variables/#variable-resolution-with-path-building","title":"Variable Resolution with Path Building","text":"<p>Variables can also be used when building paths programmatically:</p> <pre><code>from structpath import Structpath\n\n# Create a path with variables\npath = Structpath()\npath.push_key(\"users\")\npath.push_key_variable(\"userId\")\npath.push_key(\"addresses\")\npath.push_index_variable(\"addrIdx\")\n\n# Now the path is equivalent to: $users.#userId.addresses[#addrIdx]\nassert str(path) == \"$users.#userId.addresses[#addrIdx]\"\n\n# Use the path\ndata = {\n    \"users\": {\n        \"user1\": {\n            \"addresses\": [\n                {\"type\": \"home\", \"city\": \"New York\"},\n                {\"type\": \"work\", \"city\": \"Boston\"}\n            ]\n        }\n    }\n}\n\nhome_city = path.get(data, {\"userId\": \"user1\", \"addrIdx\": \"0\"})[\"city\"]\nassert home_city == \"New York\"\n\nwork_city = path.get(data, {\"userId\": \"user1\", \"addrIdx\": \"1\"})[\"city\"]\nassert work_city == \"Boston\"\n</code></pre>"},{"location":"variables/#multiple-variable-patterns","title":"Multiple Variable Patterns","text":"<p>You can use multiple path patterns with different variables to access related data:</p> <pre><code>from structpath import Structpath\n\n# Organization data\norg_data = {\n    \"departments\": {\n        \"eng\": {\"name\": \"Engineering\", \"budget\": 1000000},\n        \"mkt\": {\"name\": \"Marketing\", \"budget\": 500000}\n    },\n    \"employees\": {\n        \"alice\": {\"department\": \"eng\", \"salary\": 120000},\n        \"bob\": {\"department\": \"eng\", \"salary\": 110000},\n        \"charlie\": {\"department\": \"mkt\", \"salary\": 90000}\n    }\n}\n\n# Find employees and their departments\nemployee_path = Structpath.parse(\"$employees.#empId\")\ndept_id_path = Structpath.parse(\"$employees.#empId.department\")\ndept_name_path = Structpath.parse(\"$departments.#deptId.name\")\n\nemployee_info = {}\nfor vars_dict, employee in employee_path.iter(org_data):\n    emp_id = vars_dict[\"empId\"]\n\n    # Get the employee's department ID\n    dept_id = dept_id_path.get(org_data, {\"empId\": emp_id})\n\n    # Get the department name using the department ID\n    dept_name = dept_name_path.get(org_data, {\"deptId\": dept_id})\n\n    employee_info[emp_id] = {\n        \"salary\": employee[\"salary\"],\n        \"department\": dept_name\n    }\n\nassert employee_info[\"alice\"][\"department\"] == \"Engineering\"\nassert employee_info[\"charlie\"][\"department\"] == \"Marketing\"\nassert employee_info[\"bob\"][\"salary\"] == 110000\n</code></pre>"}]}